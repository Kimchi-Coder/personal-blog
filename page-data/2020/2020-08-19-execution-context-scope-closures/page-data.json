{"componentChunkName":"component---src-templates-blog-post-template-js","path":"/2020/2020-08-19-execution-context-scope-closures/","result":{"data":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Execution Context, Scope, and Closures\",\n  \"date\": \"2020-08-19T00:00:00.000Z\",\n  \"published\": true\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Execution Context, Scope, and Closures\"), mdx(\"p\", null, \"To understand closures, we first must understand execution context and scope.  Let's look at a simple function to see how scope works.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"let fruits = ['apple', 'banana', 'orange'];\\n\\nfunction logFruits() {\\n  let fruits = ['watermelon', 'grapefruit'];\\n\\n  for (let fruit of fruits) {\\n    console.log(fruit);\\n  }\\n}\\n\\nlogFruits();\\n\\nconsole.log(fruits);\\n\")), mdx(\"h3\", null, \"Scope\"), mdx(\"p\", null, \"Scope can be thought of as code between curly braces {}. The more nested the curly braces, the more narrow the scope.  Anything defined directly on the window itself is a part of the global scope.  So, the global scope here contains fruits, logFruits and the invoking of logFruit and console.log.\\nWe also have a more narrow scope in the logFruits function which contains another fruits array and a for-loop. An even narrower scope exists for the console.log(fruit) within the for-loop.\"), mdx(\"p\", null, \"Now, referencing values can only go from narrow to global, and not the other way around. So, when evalutaing code, the engine first looks at the current scope.\\nWhen logFruits(fruits) is invoked, the exection context and scope is let fruits = \", \"[...]\", \" and the for-loop.  The for-loop references an iterable, in this case the fruits array, and thusly looks within the current execution context for something called 'fruits'.  Since it exists, the for-loop executes for \", \"['watermelon','grapefruit']\", \".\\nHowever, what happens if fruits does not exist in the current scope?\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"function logFruits() {\\n   for (let fruit of fruits) {\\n     console.log(fruit);\\n   }\\n }\\n\")), mdx(\"p\", null, \"Since there is no fruits iterable in the current scope, the JS engine knows to look at the next parent scope of the function (i.e. the global scope).\\nGreat, fruits exists here! So we use this array and get apple, banana, orange logged to the console. This illustrates how scope may move from narrow to more global.\"), mdx(\"p\", null, \"Now, let's create a function that returns an array of functions. In this case, the functions in the\\narray will simply call console.log(i). Note that 'i' is created using \\\"var i\\\" and comes from a for-loop in createFunctions and\\nis what is referenced when the console.log is called.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"function createFunctionsVar() {\\n  let arr = [];\\n  for (var i = 0; i < 3; i++) {\\n    arr.push(function () {\\n      console.log(i);\\n    });\\n  }\\n\\n  return arr;\\n}\\n\\nlet fnsArrVar = createFunctionsVar();\\n\")), mdx(\"p\", null, \"Now we have our array of functions in 'fnsArr' and can call each individual functions as so.\\nBut, what will the console log?\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"fnsArrVar[0](); // 3\\nfnsArrVar[1](); // 3\\nfnsArrVar[2](); // 3\\n\")), mdx(\"p\", null, \"If you expected '3,' great job. However, most people expect 0 1 2. So, what exactly is going on?\\nBefore ES6 and the 'let' keyword, var was used. As the for-loop pushes functions into the array, there is a single execution context that holds the variable var i in memory. This execution context \\\"closes\\\" over this code block and keeps all necessary references in memory.\\nAfter creating the third function, i increments to 3, the for-loop sees that 'i' is no longer less than 3, and the loop ends. Now, here's the interesting part: the execution context of the for-loop is now gone.\\nHowever, the variable 'i' still lives in memory, and, since each function was created under the same closure, they will all find the same 'i,' when invoked.\"), mdx(\"p\", null, \"Now let's change that var i to let i and see what happens.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"function createFunctionsLet() {\\n  let arr = [];\\n  for (let i = 0; i < 3; i++) {\\n    arr.push(function () {\\n      console.log(i);\\n    });\\n  }\\n\\n  return arr;\\n}\\n\\nlet fnsArrLet = createFunctionsLet();\\n\\nfnsArrLet[0](); // 0\\nfnsArrLet[1](); // 1\\nfnsArrLet[2](); // 2\\n\")), mdx(\"p\", null, \"There we go! This is the magic of let vs var clearly displayed with closures. Similar to var, with let the for-loop creates an execution context that holds the i variable, but it actually creates a new closure each time i is incremented.  Therefore, when we invoke these functions, fnsArrLet\", \"[0]\", \" references a completely different i from fnsArrLet\", \"[1]\", \" and fnsArrLet\", \"[2]\", \". \"), mdx(\"h3\", null, \"Obj desctructuring on an array\"), mdx(\"p\", null, \"Let's say we have an arr as such:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\\n\")), mdx(\"p\", null, \"We could use array desctructuring like so...\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const [, , , three, , , six, , , , ten] = arr;\\nconsole.log(three) // 3\\nconsole.log(six) // 6\\nconsole.log(ten) // 10\\n\")), mdx(\"p\", null, \"To even use array destructuring in this manner, we must know the index of the items we want.\\nHowever, we have to skip items we don't want with commas, and messing with commas is ugly.\\nSo, let's use object desctructuring instead...\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const { 1: one, 5: five, 8: eight } = arr;\\n\\nconsole.log(one) // 1\\nconsole.log(five) // 5\\nconsole.log(eight) // 8\\n\")), mdx(\"p\", null, \"Here, we use the array's indices as the keys and set the name of the variable we are declaring after the :\\nThis looks much cleaner, and we are less prone to making mistakes by miscounting commas.\\nFurther, just imagine an array of thousands of items! Object desctructuring works so much better.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Execution Context, Scope, and Closures","date":"August 19th, 2020"}}},"pageContext":{"slug":"/2020/2020-08-19-execution-context-scope-closures/","previous":null,"next":{"fields":{"slug":"/2020/2020-08-20-random-post/"},"frontmatter":{"title":"My Random Post!"}}}},"staticQueryHashes":["4080856488"]}